\subsection{William Rowan Hamilton}
Fue un matemático, físico, y astrónomo irlandés, que hizo importantes contribuciones al desarrollo de la óptica, la dinámica, y el álgebra.

\subsection{Camino en un grafo}
En teoría de grafos, un camino (en inglés, walk,y en ocasiones traducido también como recorrido) es una sucesión de vértices y aristas dentro de un grafo, que empieza y termina en vértices, tal
que cada vértice es incidente con las aristas que le siguen y le preceden en la secuencia. Dos vértices están conectados o son accesibles si existe un camino que forma una trayectoria para llegar de
uno al otro; en caso contrario, los vértices están desconectados o bien son inaccesibles.

\subsection{Ciclo en un grafo}
La palabra ciclo se emplea en teoría de grafos para indicar un camino cerrado en un grafo, es
decir, en que el nodo de inicio y el nodo final son el mismo.

\subsection{Problema \emph{NP-Hard}}
Un problema NP-completo es uno que puede convertirse en otro problema NP en un tiempo polinomial razonable. Así, si se tiene un algoritmo P para una incógnita NP-completa, entonces se tiene un algoritmo P para todos los problemas NP y NP=P. Se puede entonces pensar en un ejercicio de este tipo como una representación universal de estos casos.

Un problema NP-difícil es cualquier tipo de problema, no necesariamente en el conjunto de los NP, que puede ser reducido a uno NP-completo en un tiempo polinomial razonable. En este sentido, los problemas NP-difíciles son al menos tan difíciles como los problemas NP-completos, pero podrían ser mucho más difíciles. Por ejemplo, supongamos que se tiene una solución exponencial a un problema NP-difícil que puede ser convertida a una solución exponencial de un problema NP. Se tiene un tiempo exponencial de solución al problema NP, pero puede que tenga otra solución que trabaje en tiempo polinomial.

\subsection{Grado del nodo}
El grado de un nodo es la cantidad de aristas que inciden en él. Una arista incide en un nodo si lo conecta con otro nodo (o consigo mismo, en el caso de un bucle). Dicho de otro modo: una arista incide en un nodo si lo toca con uno de sus dos lados.

\subsection{Algoritmo de retroceso (\emph{backtracking})}
Los algoritmos de vuelta atrás o retroceso (backtracking en inglés) se basan en recorrer el espacio completo de las soluciones posibles al problema planteado. Esta técnica es la aplicación directa del método de búsqueda conocido como primero en profundidad. Típicamente, los algoritmos de vuelta atrás no realizan ningún tipo de optimización y recorren el árbol de soluciones completo. Sin embargo, es posible aplicarles una poda para no descender en aquellas ramas que, de antemano, se sabe que no conducen a una solución. 

\subsection{Programación Dinámica}
La programación dinámica es un método para reducir el tiempo de ejecución de un algoritmo
mediante la utilización de subproblemas superpuestos y subestructuras óptimas.

La teoría de programación dinámica se basa en una estructura de optimización, la cual consiste
en descomponer el problema en subproblemas (más manejables). Los cálculos se realizan entonces recursivamente donde la solución óptima de un subproblema se utiliza como dato de entrada
al siguiente problema. Por lo cual, se entiende que el problema es solucionado en su totalidad,
una vez se haya solucionado el último subproblema. Dentro de esta teoría, Bellman desarrolla el
Principio de Optimalidad, el cual es fundamental para la resolución adecuada de los cálculos recursivos. Lo cual quiere decir que las etapas futuras desarrollan una política óptima independiente
de las decisiones de las etapas predecesoras. Es por ello, que se define a la programación dinámica como una técnica matemática que ayuda a resolver decisiones secuenciales interrelacionadas,
combinándolas para obtener de la solución óptima.

\subsection{Máscara de bits}
Esta idea algorítmica permite generar todos los posibles subconjuntos de un conjunto de elementos y puede ser utilizados en problemas en donde se debe contar la cantidad de subcojuntos de un conjunto inicial que cumplan con determinadas condiciones. En este caso la máscara serviría para generar todos los posibles subconjuntos y luego bastaría con chequear cada subconjunto generado y contar con aquellos que cumplan con restricciones o condiciones que imponga el problema.