Esta estructura es una derivación del método/estructura de descomposición en raíz cuadrada de ahí su nombre de árbol de raíz cuadrada (\emph{SQRT Tree}). 

\subsection{Construyendo la descomposición raíz cuadrada}

Hagamos una descomposición raíz cuadrada. Dividimos el arreglo en $\sqrt{n}$ bloques, cada bloque tiene tamaño $\sqrt{n}$. Para cada bloque, calculamos:

\begin{enumerate}
	\item Respuestas a las consultas que se encuentran en el bloque y comienzan al principio del bloque ($\text{prefixOp}$)
	\item Respuestas a las consultas que se encuentran en el bloque y terminan al final del bloque ($\text{suffixOp}$)
\end{enumerate} 

Y calcularemos una matriz adicional:

\begin{enumerate}
	\item $\text{between}_{i, j}$ (for $i \le j$) respuesta a la consulta que comienza al inicio del bloque $i$ y termina al final del bloque $j$ . Tenga en cuenta que tenemos
	$\sqrt{n}$ bloques, por lo que el tamaño de esta matriz será $O(\sqrt{n}^2) = O(n)$.
\end{enumerate}

Veamos el ejemplo. La operación $\circ$ pasa a ser $+$ (calculamos la suma en un rango) y tenemos el siguiente arreglo $a$:

         $$\{~1,~2,~3,~4,~5,~6,~7,~8,~9\}$$

Se dividirá en tres bloques: $\{~1,~2,~3\}$, $\{~4,~5,~6\}$, $\{~7,~8,~9\}$. Para el primer bloque $\text{prefixOp}$ es $\{~1,~3,~6\}$ y $\text{suffixOp}$ es $\{~6,~5,~3\}$. Para el segundo bloque $\text{prefixOp}$ es $\{~4,~9,~15\}$ y $\text{suffixOp}$ es $\{~15,~11,~6\}$. Mientras la matriz $\text{between}$ queda conformada de la siguiente manera. 


$$
\begin{matrix}
 \{ &	&  &  & \\	
 &	\{6,& 21, & 45\}, & \\
 & \{0,& 15, & 39\},  & \\
 &	\{0,& 0, & 24\}, & \\
 &	&  &  &  \} 
\end{matrix}
$$

(asumimos que los elementos no válidos donde i > j están llenos de ceros). Es obvio ver que estas arreglos y matrices se pueden calcular fácilmente en O($n$) tiempo y memoria.

Ya podemos responder algunas consultas utilizando estas matrices. Si la consulta no cabe en un bloque, podemos dividirla en tres partes: el sufijo de un bloque, luego algún segmento de bloques contiguos y luego el prefijo de algún bloque. Podemos responder una consulta dividiéndola en tres
partes y tomando nuestra operación de algún valor de suffixOp , entonces algún valor de between , entonces algún valor de prefixOp.

Pero si tenemos consultas que encajan completamente en un bloque, no podemos procesarlas usando estas tres matrices. Entonces, necesitamos
hacer algo.

\subsection{Construyendo un árbol}

\subsection{Optimización de la complejidad de la consulta}

\subsection{Actualizando elementos}

También podemos actualizar elementos en un árbol de raíz cuadrada. Se admiten tanto actualizaciones de un solo elemento como actualizaciones de un rango.

\subsubsection{Actualizando un solo elemento}

\textbf{Enfoque ingenuo}

\textbf{Un árbol raíz cuadrada dentro del árbol raíz cuadrada}

\subsubsection{Actualizando un rango}

\textbf{Primer enfoque}

\textbf{Segundo enfoque}


