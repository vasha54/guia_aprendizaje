\subsection{C++}

Primero, el enfoque recursivo, que es una traducción directa de la fórmula recursiva:

\begin{lstlisting}[language=C++]
int binpow (int a, int n){
   if(n == 0) return 1; 
   if(n% 2 == 1) return binpow (a, n - 1) * a; 
   else {
      int b = binpow (a, n / 2); 
      return b * b;
   }
}
\end{lstlisting}

El segundo enfoque logra la misma tarea sin recursividad. Calcula todas las potencias en un bucle y multiplica las que tienen el bit establecido correspondiente en $n$. Aunque la complejidad de ambos enfoques es idéntica, este enfoque será más rápido en la práctica ya que no tenemos la sobrecarga de las llamadas recursivas.

\begin{lstlisting}[language=C++]
int binpow (int a, int n){
   int res = 1; 
   while (n){
      if(n&1) res*= a;
      a*=a;
      n>>=1;
   } 
   return res;
}
\end{lstlisting}

\subsection{Java}

Primero, el enfoque recursivo, que es una traducción directa de la fórmula recursiva:

\begin{lstlisting}[language=C++]
public int binpow (int a, int n){
   if(n == 0) return 1; 
   if(n% 2 == 1) return binpow (a, n - 1) * a; 
   else {
      int b = binpow (a, n / 2); 
      return b * b;
   }
}
\end{lstlisting}

El segundo enfoque logra la misma tarea sin recursividad. Calcula todas las potencias en un bucle y multiplica las que tienen el bit establecido correspondiente en $n$. Aunque la complejidad de ambos enfoques es idéntica, este enfoque será más rápido en la práctica ya que no tenemos la sobrecarga de las llamadas recursivas.

\begin{lstlisting}[language=C++]
public int binpow (int a, int n){
   int res = 1; 
   while (n){
      if(n&1) res*= a;
      a*=a;
      n>>=1;
   } 
   return res;
}
\end{lstlisting}