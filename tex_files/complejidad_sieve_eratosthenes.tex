La implementación clásica consume $O(n)$ de la memoria (obviamente) y realiza $O(n \log \log n)$
operaciones. Es sencillo demostrar un tiempo de ejecución de $O(n \log n)$ sin saber nada sobre la 
distribución de números primos: ignorando la \emph{is\_prime} verificación, el bucle interno se 
ejecuta (como máximo) $n/i$ tiempos para $i = 2, 3, 4, \dots $, lo que hace que el número total de 
operaciones en el bucle interno sea una suma armónica como $n(1/2 + 1/3 + 1/4 + \cdots)$, que está 
delimitada por $O(n \log n)$.

Demostremos que el tiempo de ejecución del algoritmo es $O(n \log \log n)$. El algoritmo realizará
$\frac{n}{p}$ operaciones para cada primo $p \le n$ en el bucle interior. Por tanto, necesitamos 
evaluar la siguiente expresión:

$$\sum_{\substack{p \le n, \\\ p \text{ prime}}} \frac n p = n \cdot \sum_{\substack{p \le n, \\\ p \text{ prime}}} \frac 1 p.$$

Recordemos dos hechos conocidos.

\begin{itemize}
	\item El número de números primos menores o iguales a $n$ es aproximadamente $\frac n {\ln n}$.
	\item El $k$-ésimo número primo aproximadamente igual $k\ln k$ (esto se sigue inmediatamente del hecho anterior).
\end{itemize}

Así podemos escribir la suma de la siguiente manera:

$$\sum_{\substack{p \le n, \\\ p \text{ prime}}} \frac 1 p \approx \frac 1 2 + \sum_{k = 2}^{\frac n {\ln n}} \frac 1 {k \ln k}.$$

Aquí extrajimos el primer número primo 2 de la suma, porque $k = 1$ en aproximación $k \ln k$ es $0$ y provoca una división por cero.

Ahora, evalúemos esta suma usando la integral de una misma función sobre $k$ de $2$ a $\frac n {\ln n}$ (Podemos hacer tal aproximación porque, de hecho, la suma está relacionada con la integral como su aproximación usando el método del rectángulo):

$$\sum_{k = 2}^{\frac n {\ln n}} \frac 1 {k \ln k} \approx \int_2^{\frac n {\ln n}} \frac 1 {k \ln k} dk$$

La antiderivada del integrando es $\ln \ln k$. Usando una sustitución y eliminando términos de orden inferior, obtendremos el resultado:

$$\int_2^{\frac n {\ln n}} \frac 1 {k \ln k} dk = \ln \ln \frac n {\ln n} - \ln \ln 2 = \ln(\ln n - \ln \ln n) - \ln \ln 2 \approx \ln \ln n$$

Ahora, volviendo a la suma original, obtendremos su valoración aproximada:


$$\sum_{\substack{p \le n, \\\ p\ is\ prime}} \frac n p \approx n \ln \ln n + o(n)$$

Puede encontrar una prueba más estricta (que brinda una evaluación más precisa y precisa dentro de multiplicadores constantes) en el libro escrito por Hardy \& Wright \emph{Una introducción a la teoría de los números} (p. 349).

La optimización de iterar hasta la raíz no afecta la complejidad (de hecho, al repetir la prueba presentada anteriormente obtendremos la evaluación $n \ln \ln \sqrt n + o(n)$, que es asintóticamente igual según las propiedades de los logaritmos), aunque el número de operaciones se reducirá notablemente.

La optimización de iterar los impares primero, nos permitirá reducir a la mitad la memoria necesaria. En segundo lugar, reducirá el número de operaciones realizadas por el algoritmo aproximadamente a la mitad.

El tiempo de ejecución de iterar por bloques es el mismo que el del tamiz normal de Eratóstenes (a menos que el tamaño de los bloques sea muy pequeño), pero la memoria necesaria se reducirá a $O(\sqrt{n}+S)$ y tenemos mejores resultados de almacenamiento en caché. Por otro lado, habrá una división para cada par de bloque y número primo de $[1; \sqrt{n}]$, y eso será mucho peor para bloques de menor tamaño. Por lo tanto, es necesario mantener el equilibrio al seleccionar la constante $S$. Logramos los mejores resultados para tamaños de bloque entre $10^4$ y $10^5$.

La complejidad temporal del primer enfoque de encontrar los primos en un rango es $O((R-L+1) \log \log (R)+\sqrt R \log \log \sqrt R)$. Mientras el segundo enfoque  la complejidad es peor, lo cual es $O((R-L+1) \log (R)+\sqrt R)$. Sin embargo, en la práctica sigue funcionando muy rápido.  

Podemos modificar el algoritmo de tal manera que solo tenga complejidad de tiempo lineal. Este enfoque lo vamos analizar en otro momento. Sin embargo, este algoritmo también tiene sus propias debilidades.