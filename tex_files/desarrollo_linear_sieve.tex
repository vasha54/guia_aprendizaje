El algoritmo se centra en calcular el factor primo mínimo para cada número en el rango $[2,N]$ . 

Además, necesitamos almacenar la lista de todos los números primos encontrados, llamémoslo $pr[]$

Inicializaremos los valores $lp[i]$ con ceros, lo que significa que asumimos que todos los números son primos. Durante la ejecución del algoritmo, este vector se llenará gradualmente.

Ahora repasaremos los números del 2 al $N$. Tenemos dos casos para el número actual $i$:

\begin{enumerate}
	\item $lp[i] = 0$ significa que $i$ es primo, es decir, no hemos encontrado factores menores para él. Por lo tanto, asignamos $lp[i]= i$ y agregamos $i$ al final de la lista $pr[]$. 
	\item $lp[i] != 0$ significa que $i$ es compuesto y que su mínimo factor primo es $lp[i]$
\end{enumerate}  

En ambos casos actualizamos los valores $lp[]$ de para los números que son divisibles por $i$. Sin embargo, nuestro objetivo es aprender a hacerlo para establecer un valor como máximo una vez para cada número $lp[]$. Podemos hacerlo de la siguiente manera:

Consideremos los números $x_j = i \cdot p_j$ donde $p_j$ son todos los números primos menores o iguales que $lp [i]$ (por eso necesitamos almacenar la lista de todos los números primos).

Estableceremos un nuevo valor $lp [x_j] = p_j$ para todos los números de esta forma.

\subsection{Prueba de corrección}

Necesitamos demostrar que el algoritmo establece todos los valores $lp[]$ correctamente y que cada valor se establecerá exactamente una vez. Por lo tanto, el algoritmo tendrá un tiempo de ejecución lineal, ya que todas las acciones restantes del algoritmo, obviamente, funcionan para $O(n)$.

Observe que cada número $i$ tiene exactamente una representación en la forma:

$$i = lp [i] \cdot x,$$

dónde $lp[i]$ es el factor primo mínimo de $i$, y el número $x$ no tiene factores primos menores que $lp[i]$, es decir:

$$lp [i] \le lp [x]$$

Ahora, comparemos esto con las acciones de nuestro algoritmo: de hecho, por cada $x$ pasa por todos los números primos por los que se puede multiplicar, es decir, todos los números primos hasta$lp [x]$ inclusive, para obtener los números en la forma dada anteriormente.

Por lo tanto, el algoritmo revisará cada número compuesto exactamente una vez, estableciendo los valores correctos $lp[]$ allá.