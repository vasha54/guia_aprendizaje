Es un algoritmo en la teoría de grafos para encontrar los componentes fuertemente conexa (SCC) de un grafo dirigido. Incluyen el algoritmo de Kosaraju y el algoritmo de componente fuerte basado en la ruta. El algoritmo lleva el nombre de su inventor, Robert Tarjan.

La idea básica del algoritmo es esta: una búsqueda de profundidad primero (DFS) comienza desde un nodo de inicio arbitrario (y las búsquedas posteriores de profundidad primero se realizan en cualquier nodo que aún no se haya encontrado). Como de costumbre con la búsqueda de profundidad, la búsqueda visita cada nodo del grafo exactamente una vez, declinando revisar cualquier nodo que ya haya sido visitado. Por lo tanto, la colección de árboles de búsqueda es un bosque de expansión del grafo. Las componentes fuertemente conexas se recuperarán como ciertos subárboles de este bosque. Las raíces de estos subárboles se llaman \emph{raíces} de los componentes fuertemente conexas. Cualquier nodo de una componente fuertemente conexa podría servir como raíz, si es el primer nodo de un componente que descubre la búsqueda.

Los nodos se colocan en una pila en el orden en que se visitan. Cuando la búsqueda de profundidad primero visita un nodo $v$ y sus descendientes, esos nodos no están necesariamente surgidos de la pila cuando esta llamada recursiva regresa. La propiedad invariante crucial es que un nodo permanece en la pila después de que se haya visitado si y solo si existe una ruta en el grafo de entrada a algún nodo antes en la pila. En otras palabras, significa que en el DFS un nodo solo se eliminaría de la pila después de que todas sus rutas conectadas se hayan recorrido. Cuando el DFS retrocede, eliminaría los nodos en una sola ruta y volvería a la raíz para iniciar una nueva ruta.

Al final de la llamada que visita $v$ y sus descendientes, sabemos si $v$ tiene un camino hacia cualquier nodo antes en la pila. Si es así, la llamada regresa, dejando $v$ en la pila para preservar el invariante. Si no, entonces $v$ debe ser la raíz de su componente fuertemente conectado, que consiste en $v$ junto con cualquier nodo más adelante en la pila que $v$ (tales nodos tienen rutas de regreso a $v$ pero no a ningún nodo anterior, porque si tenían rutas a los nodos anteriores, $v$ también tendría caminos a nodos anteriores que es falso). El componente conectado enraizado en $v$ se mueve desde la pila y se devuelve, preservando nuevamente el invariante.

A cada nodo $v$ se le asigna un entero único $v.index$, que numera los nodos consecutivamente en el orden en que se descubren. También mantiene un valor $v.lowlink$ que representa el índice más pequeño de cualquier nodo en la pila que se sabe que es accesible desde $v$ hasta el subárbol DFS de $v$, incluido $v$ mismo. Por lo tanto, $v$ debe dejarse en la pila si $v.lowlink < v.index$, mientras que $v$ debe eliminarse como la raíz de un componente fuertemente conectado si $v.lowlink == v.index$. El valor $v.lowlink$ se calcula durante la búsqueda en profundidad desde $v$, ya que encuentra los nodos a los que se puede acceder desde $v$.

Si bien no hay nada especial en el orden de los nodos dentro de cada componente fuertemente conxa, una propiedad útil del algoritmo es que no se identificará ningún componente fuertemente conexa antes que cualquiera de sus sucesores. Por lo tanto, el orden en el que se identifican las componentes fuertemente conexas constituye un tipo topológico inverso del DAG formado por las componentes fuertemente conxexas.