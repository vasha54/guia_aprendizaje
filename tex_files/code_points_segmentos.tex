\subsection{C++}

\begin{lstlisting}[language=C++]
#include <stdio.h>
#include <math.h>
#include <iostream>
#include <algorithm>
#include <complex>
using namespace std;
typedef long long lld;
	
struct Point{
   double X, Y;
   Point(double x, double y){
      this.X = x;
      this.Y = y;
   }
};
	
inline double crossProduct(Point a, Point b, Point c){
   return ((b.X - a.X) * (c.Y - a.Y) - (b.Y - a.Y) * (c.X - a.X));
}
	
inline bool isLeft(Point a, Point b, Point c){
   return (crossProduct(a, b, c) > 0);
}
	
inline bool isCollinear(Point a, Point b, Point c){
   return (crossProduct(a, b, c) == 0);
}
	
inline bool oppositeSides(Point a, Point b, Point c, Point d){
   return (isLeft(a, b, c) != isLeft(a, b, d));
}
	
inline bool isBetween(Point a, Point b, Point c){
   return (min(a.X, b.X) <= c.X && c.X <= max(a.X, b.X) && min(a.Y, b.Y) <= c.Y && c.Y <= max(a.Y,b.Y));
}

inline bool intersect(Point a, Point b, Point c, Point d){
   if (isCollinear(a, b, c) && isBetween(a, b, c)) return true;
   if (isCollinear(a, b, d) && isBetween(a, b, d)) return true;
   if (isCollinear(c, d, a) && isBetween(c, d, a)) return true;
   if (isCollinear(c, d, b) && isBetween(c, d, b)) return true;
   return (oppositeSides(a, b, c, d) && oppositeSides(c, d, a, b));
}

double dist(Point A, Point B) {
   return hypot(A.X - B.X, A.Y - B.Y);
}
	
int main(){
   Point A(0.0, 0.0), B(0.0, 2.0), C(-1.0, 2.0), D(1.0, 2.0);
   printf(intersect(A,B,C,D) ? "YES" : "NO");
   printf("\n");
   return 0;
}
	
\end{lstlisting} 

\subsection{Java}

\begin{lstlisting}[language=Java]
private class Point{
   public double X;
   public double Y;
	
   public Point(double x, double y){
      this.X = x;
      this.Y = y;
   }
}

public double crossProduct(Point a, Point b, Point c){
   return ((b.X - a.X) * (c.Y - a.Y) - (b.Y - a.Y) * (c.X - a.X));
}

public boolean isLeft(Point a, Point b, Point c){
   return (crossProduct(a, b, c) > 0);
}

public boolean isCollinear(Point a, Point b, Point c){
   return (crossProduct(a, b, c) == 0);
}

public boolean oppositeSides(Point a, Point b, Point c, Point d){
   return (isLeft(a, b, c) != isLeft(a, b, d));
}

public boolean isBetween(Point a, Point b, Point c){
   return (Math.min(a.X, b.X) <= c.X && c.X <= Math.max(a.X, b.X) && Math.min(a.Y, b.Y) <= c.Y && c.Y <= Math.max(a.Y,b.Y));
}

public boolean intersect(Point a, Point b, Point c, Point d){
   if (isCollinear(a, b, c) && isBetween(a, b, c)) return true;
   if (isCollinear(a, b, d) && isBetween(a, b, d)) return true;
   if (isCollinear(c, d, a) && isBetween(c, d, a)) return true;
   if (isCollinear(c, d, b) && isBetween(c, d, b)) return true;
   return (oppositeSides(a, b, c, d) && oppositeSides(c, d, a, b));
}

public double dist(Point A, Point B) {
   return Math.hypot(A.X- B.X, A.Y - B.Y);
}
\end{lstlisting}
